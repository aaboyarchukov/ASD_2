# Рефлексия

В данном занятии необходимо реализовать класс дерева вместе с методами вставки, удаления и поиска. 
При разработке методов я понял, что работа с деревом по структуре во многом похожа со связным список, поэтому понимание как решать очередную задачу, приходило сразу. При решении задач важно было следить за изменением связей и добавлением новых, а также правильно понимать как применять рекурсию.

Что касаемо дополнительных задач:
1. Подсчет и вывод уровней каждого узла - в данной задаче необходимо проанализировать все дерево, и вывести уровень для каждого из узлов. Для этого необходимо знать уровень родителя, а у дочернего узла увеличивать это значение на единицу, я решил воспользоваться передачей опционального аргумента в функцию. Также, наверное, можно улучшить мое решение по памяти, если я буду в функцию передавать еще узел, а не делать нового родителя.
2. Лучшая организация уровней узлов - просто добавляем уровень как атрибут узла и при добавлении нового узла в дерево мы сразу определяем его уровень. Также можно сделать функцию, которая выводит уровень конкретного узла.

Также хочу отметить то, что в дополнительных задачах был вынужден писать тесты в одном и том же файлы, так как названия файлов были через дефис ***(example-2.py)***, что не дает возможности экспортировать код в другие пакеты.

Также напишу заметки по реализации некоторых основных методов:
1. Получение всех узлов. Думаю, что можно улучшить решение по времени выполнения за счет дополнительной функции, в которую я буду передавать в качестве аргумента список, который будет аккумулироваться, но вместо этого я решил использовать метод `extend()`, который увеличил временную сложность моего алгоритма до квадратичной.
2. Получение всех узлов по значению. В данном методе можно было применить ту же технику, что и в первом. Также можно применить встроенную функцию `filter()` на список найденных узлов, это делает код более емким, но никак не выигрывает по сложности.
Но при решении данных задач я не использовал дополнительные функции, так как думаю, что надо решать с помощью одной.